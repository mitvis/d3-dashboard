<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/d3-array.v2.min.js"></script>
</head>
<body>

<div id="chart"></div>

<script>

  var width = 1000;
  var height = 1000;

  var data = [];
  for (i = 0; i < 400000; i++) {
    data.push({
      x: Math.random() * 1000,
      y: Math.random() * 1000,
      size: Math.random() * 100,
    });
  }

  console.log(data);

  var quadtree = d3.quadtree()
      .extent([[-1, -1], [width + 1, height + 1]])
      .x(d=> d.x)
      .y(d=>d.y)
      .addAll(data);

  console.log(quadtree.data());

  function brushed(extent) {
      d3.select('rect')
        .attr('x', extent[0][0])
        .attr('y', extent[0][1])
        .attr('width', extent[1][0] - extent[0][0])
        .attr('height', extent[1][1] - extent[0][1])
  }

    // Find the nodes within the specified rectangle.
  function search(quadtree, x0, y0, x3, y3) {
    const nodes = []
    console.log(quadtree.size());
    quadtree.visit((node, x1, y1, x2, y2) => {
      // node.data contient les points Ã  retracer
      if (!node.length) {
        do {
          var d = node.data;
          d.scanned = true;
          d.selected = (d.x >= x0) && (d.x < x3) && (d.y >= y0) && (d.y < y3);
          if (d.selected) nodes.push(d)
        } while (node = node.next);
      }
      return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
    });
    console.log(nodes);
    return nodes
  }


  let nbCities = 1000; // n biggest cities to draw
  background = false;
  tau = 3.14159265358979 * 2;


  draw = (context, points, t) => {
    let nbtotal = points.length;

    if (points.length > nbCities) {
      points = points.slice();
      d3.quickselect(   // very nice suggestion from https://observablehq.com/@fil Thanks!!
        points,
        nbCities,
        0,
        points.length - 1,
        (a, b) => b.size - a.size
      );
      points.splice(nbCities, points.length - 1)
    }
    let nbrendered = points.length;
    context.globalAlpha = 0.5;
    context.fillStyle = 'black';
    const k = 1 / 10 / t.k;
    for (let i = 0; i < points.length; i++) {
      const d = points[i],
        v = d.size * k;
      context.beginPath();

      context.arc(
        d.x,
        d.y,
        Math.sqrt(v),
        0,
        tau
      ) // Color, size, anything can be changed.
      context.fill()
    }

  }

  function zoom(sel) {
    console.log("zoom");
    const context = sel.node().getContext("2d");
    const zoomBehaviour = d3.zoom().on("zoom", zoomed);
    sel.call(zoomBehaviour);

    function zoomed() {
      console.log("zoomed?");
      const t = d3.event.transform;

      context.save();

      context.clearRect(0, 0, width, height);

      const viewbox = [t.invert([0, 0]), t.invert([width, height])];
      console.log(viewbox);
      setTimeout(() => brushed(viewbox), 100); //adjust the minimap

      context.translate(t.x, t.y);
      context.scale(t.k, t.k);
      const points = search(
              quadtree,
              viewbox[0][0],
              viewbox[0][1],
              viewbox[1][0],
              viewbox[1][1]
      );
      //const points = data;
      draw(context, points, t);

      context.restore();
    }
  }



  var canvas  = d3.select("#chart").append("svg")
    .attr("id", "canvas")
    .attr("width", width)
    .attr("height", height);


  d3.select(canvas).call(zoom);

  draw(canvas, data, d3.zoomIdentity);








</script>
</body>
</html>
